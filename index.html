<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Super Mangonio Bros</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<audio id="bgm" loop autoplay>
  <source src="music.mp3" type="audio/mpeg">
</audio>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const bgm = document.getElementById("bgm");

let width = window.innerWidth;
let height = window.innerHeight;
canvas.width = width;
canvas.height = height;

let keys = {};
let gameStarted = false;
let gameOver = false;
let level = 1;
let cameraX = 0;
let lives = 3;

const GRAVITY = 0.4;
let FLOOR = height - 64;

let player = {
  x: 50, y: 300, vx: 0, vy: 0,
  width: 32, height: 32,
  grounded: false,
  big: false,
  fire: false
};

let enemies = [];
let powerUps = [];
let barriers = [];
let blocks = [];
let pipes = [];
let minions = [];

function loadImage(src) {
  const img = new Image();
  img.src = src;
  return img;
}

const bg = loadImage("background.png");
const mangonio = loadImage("mangonio.png");
const enemyImg = loadImage("umpalumpa.png");
const pipeImg = loadImage("tuberia.png");
const minionImg = loadImage("minion.png");

document.addEventListener("keydown", e => {
  keys[e.key.toLowerCase()] = true;
  if (e.key.toLowerCase() === "q" && (!gameStarted || gameOver)) {
    gameStarted = true;
    gameOver = false;
    lives = 3;
    level = 1;
    resetLevel();
    bgm.play();
  }
});
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

function resetLevel() {
  player.x = 50;
  player.y = 300;
  player.vx = 0;
  player.vy = 0;
  cameraX = 0;

  if (level === 1) {
    barriers = [{ x: -50, y: 0, width: 100, height: height }];
  } else {
    barriers = [];
  }

  enemies = [
    { x: 600, y: FLOOR - 24, width: 24, height: 24, dir: 1, speed: 1 },
    { x: 900, y: FLOOR - 24, width: 24, height: 24, dir: -1, speed: 1 }
  ];

  powerUps = [
    { x: 400, y: FLOOR - 32, type: "mushroom" },
    { x: 800, y: FLOOR - 32, type: "flower" }
  ];

  blocks = [
    { x: 300, y: FLOOR - 150, width: 32, height: 32 },
    { x: 500, y: FLOOR - 150, width: 32, height: 32 }
  ];

  pipes = [
    { x: 700, y: FLOOR - 48, width: 64, height: 48 }
  ];

  minions = [
    { x: 700, y: FLOOR - 64, width: 32, height: 32, timer: 0, show: false }
  ];
}

function checkCollision(a, b) {
  return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
}

function update() {
  if (!gameStarted || gameOver) return;

  player.vx = (keys["a"] ? -2 : 0) + (keys["d"] ? 2 : 0);
  if ((keys["w"] || keys[" "]) && player.grounded) {
    player.vy = -8;
    player.grounded = false;
  }

  player.vy += GRAVITY;
  player.x += player.vx;
  player.y += player.vy;

  if (player.y + player.height >= FLOOR) {
    player.y = FLOOR - player.height;
    player.vy = 0;
    player.grounded = true;
  }

  for (let barrier of barriers) {
    if (checkCollision(player, barrier)) {
      if (player.vx < 0) {
        player.x = barrier.x + barrier.width;
      }
    }
  }

  blocks.forEach(block => {
    if (checkCollision(player, block)) {
      if (player.vy < 0) player.vy = 0;
    }
  });

  pipes.forEach(pipe => {
    if (checkCollision(player, pipe)) {
      // no daÃ±o
    }
  });

  minions.forEach(minion => {
    minion.timer++;
    if (minion.timer % 180 < 90) {
      minion.show = true;
      if (checkCollision(player, { x: minion.x, y: minion.y, width: 24, height: 24 })) {
        lives--;
        if (lives <= 0) {
          gameOver = true;
        }
        resetLevel();
      }
    } else {
      minion.show = false;
    }
  });

  enemies.forEach(e => {
    e.x += e.dir * e.speed;
    if (e.x < 0 || e.x > 1400) e.dir *= -1;
    if (checkCollision(player, e)) {
      lives--;
      if (lives <= 0) gameOver = true;
      resetLevel();
    }
  });

  powerUps = powerUps.filter(p => {
    if (checkCollision(player, { x: p.x, y: p.y, width: 16, height: 16 })) {
      if (p.type === "mushroom") player.big = true;
      if (p.type === "flower") player.fire = true;
      return false;
    }
    return true;
  });

  if (player.x > 1400) {
    level++;
    if (level > 5) {
      alert("Â¡Ganaste! Todos los niveles completados ðŸŽ‰");
      gameStarted = false;
      level = 1;
    }
    resetLevel();
  }

  cameraX = player.x - 100;
}

function draw() {
  ctx.clearRect(0, 0, width, height);

  if (!gameStarted && !gameOver) {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = "#fff";
    ctx.font = "24px monospace";
    ctx.fillText("ðŸŽ® Super Mangonio Bros ðŸŽ®", width / 2 - 150, 100);
    ctx.fillText("Presiona Q para comenzar", width / 2 - 140, 150);
    ctx.fillText("Controles: A/D/W/ESPACIO, Q, P", width / 2 - 140, 180);
    return;
  }

  if (gameOver) {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = "#fff";
    ctx.font = "30px monospace";
    ctx.fillText("ðŸ’€ GAME OVER ðŸ’€", width / 2 - 150, height / 2 - 20);
    ctx.font = "20px monospace";
    ctx.fillText("Presiona Q para continuar", width / 2 - 140, height / 2 + 20);
    return;
  }

  ctx.drawImage(bg, -cameraX * 0.5, 0, width * 2, height);
  ctx.fillStyle = "#654321";
  ctx.fillRect(-cameraX, FLOOR, 2000, 64);

  ctx.drawImage(mangonio, player.x - cameraX, player.y, player.width, player.height);

  enemies.forEach(e => {
    ctx.drawImage(enemyImg, e.x - cameraX - 12, e.y - 24, 48, 48);
  });

  powerUps.forEach(p => {
    ctx.fillStyle = p.type === "mushroom" ? "red" : "yellow";
    ctx.fillRect(p.x - cameraX, p.y, 16, 16);
  });

  blocks.forEach(b => {
    ctx.fillStyle = "#FFA500";
    ctx.fillRect(b.x - cameraX, b.y, b.width, b.height);
  });

  pipes.forEach(p => {
    ctx.drawImage(pipeImg, p.x - cameraX, p.y, p.width, p.height);
  });

  minions.forEach(m => {
    if (m.show) ctx.drawImage(minionImg, m.x - cameraX, m.y, m.width, m.height);
  });

  ctx.fillStyle = "#fff";
  ctx.font = "16px monospace";
  ctx.fillText("Nivel " + level, 20, 30);
  for (let i = 0; i < lives; i++) {
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(width - 20 - i * 30, 30, 10, 0, Math.PI * 2);
    ctx.fill();
  }
}

function loop() {
  update();
  draw();
  setTimeout(() => requestAnimationFrame(loop), 1000 / 60);
}

resetLevel();
loop();
</script>
</body>
</html>
