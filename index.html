<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Super Mangonio Bros</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<audio id="bgm" loop autoplay>
  <source src="music.mp3" type="audio/mpeg" />
</audio>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const bgm = document.getElementById("bgm");

let width = window.innerWidth;
let height = window.innerHeight;
canvas.width = width;
canvas.height = height;

let keys = {};
let gameStarted = false;
let gameOver = false;
let level = 1;
let cameraX = 0;
let lives = 3;

const GRAVITY = 0.4;
let FLOOR = height - 64;

let player = {
  x: 50, y: 300, vx: 0, vy: 0,
  width: 32, height: 32,
  grounded: false,
  big: false,
  fire: false
};

let enemies = [];
let powerUps = [];
let barriers = [];
let blocks = [];
let pipes = [];
let minions = [];

function loadImage(src) {
  const img = new Image();
  img.src = src;
  return img;
}

const bg = loadImage("background.png");
const mangonio = loadImage("mangonio.png");
const enemyImg = loadImage("umpalumpa.png");
const pipeImg = loadImage("tuberia.png");
const minionImg = loadImage("minion.png");

document.addEventListener("keydown", e => {
  keys[e.key.toLowerCase()] = true;
  if (e.key.toLowerCase() === "q" && (!gameStarted || gameOver)) {
    gameStarted = true;
    gameOver = false;
    lives = 3;
    level = 1;
    resetLevel();
    bgm.play();
  }
});
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

function resetLevel() {
  player.x = 50;
  player.y = 300;
  player.vx = 0;
  player.vy = 0;
  cameraX = 0;

  if (level === 1) {
    barriers = [{ x: -50, y: 0, width: 100, height: height }];
  } else {
    barriers = [];
  }

  enemies = [
    { x: 600, y: FLOOR - 24, width: 24, height: 24, dir: 1, speed: 1 },
    { x: 900, y: FLOOR - 24, width: 24, height: 24, dir: -1, speed: 1 }
  ];

  // Quitamos powerUps (mushroom rojo y flower amarillo)
  powerUps = [];

  // Quitamos los cubos naranjas (blocks) eliminando array o dejándolo vacío
  blocks = [];

  pipes = [
    { x: 700, y: FLOOR - 48, width: 64, height: 48 }
  ];

  // Minion siempre visible y se moverá verticalmente
  minions = [
    { x: 700, y: FLOOR - 64, width: 32, height: 32, vy: -0.5 } // velocidad vertical para subir y bajar
  ];
}

function checkCollision(a, b) {
  return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
}

function update() {
  if (!gameStarted || gameOver) return;

  // Player corre un poco más rápido que el minion (minion vy=0.5, player vx será 3)
  player.vx = (keys["a"] ? -3 : 0) + (keys["d"] ? 3 : 0);
  if ((keys["w"] || keys[" "]) && player.grounded) {
    player.vy = -8;
    player.grounded = false;
  }

  player.vy += GRAVITY;
  player.x += player.vx;
  player.y += player.vy;

  if (player.y + player.height >= FLOOR) {
    player.y = FLOOR - player.height;
    player.vy = 0;
    player.grounded = true;
  }

  for (let barrier of barriers) {
    if (checkCollision(player, barrier)) {
      if (player.vx < 0) {
        player.x = barrier.x + barrier.width;
      }
    }
  }

  // Quitamos colisiones con bloques porque ya no existen

  pipes.forEach(pipe => {
    if (checkCollision(player, pipe)) {
      // no daño ni nada
    }
  });

  // Minion movimiento vertical de abajo hacia arriba (loop)
  minions.forEach(minion => {
    minion.y += minion.vy;

    // Cuando llegue muy arriba o abajo invierte dirección para que suba y baje suavemente
    if (minion.y < FLOOR - 90) minion.vy = 0.5;
    if (minion.y > FLOOR - 64) minion.vy = -0.5;

    // El minion no desaparece ni aparece, no colisiona
  });

  enemies.forEach(e => {
    e.x += e.dir * e.speed;
    if (e.x < 0 || e.x > 1400) e.dir *= -1;
    if (checkCollision(player, e)) {
      lives--;
      if (lives <= 0) gameOver = true;
      resetLevel();
    }
  });

  // powerUps están vacíos, no colisiona nada ni los recoge

  if (player.x > 1400) {
    level++;
    if (level > 5) {
      alert("¡Ganaste! Todos los niveles completados 🎉");
      gameStarted = false;
      level = 1;
    }
    resetLevel();
  }

  cameraX = player.x - 100;
}

function draw() {
  ctx.clearRect(0, 0, width, height);

  if (!gameStarted && !gameOver) {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = "#fff";
    ctx.font = "24px monospace";
    ctx.fillText("🎮 Super Mangonio Bros 🎮", width / 2 - 150, 100);
    ctx.fillText("Presiona Q para comenzar", width / 2 - 140, 150);
    ctx.fillText("Controles: A/D/W/ESPACIO, Q, P", width / 2 - 140, 180);
    return;
  }

  if (gameOver) {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = "#fff";
    ctx.font = "30px monospace";
    ctx.fillText("💀 GAME OVER 💀", width / 2 - 150, height / 2 - 20);
    ctx.font = "20px monospace";
    ctx.fillText("Presiona Q para continuar", width / 2 - 140, height / 2 + 20);
    return;
  }

  // Fondo y suelo
  ctx.drawImage(bg, -cameraX * 0.5, 0, width * 2, height);
  ctx.fillStyle = "#654321";
  ctx.fillRect(-cameraX, FLOOR, 2000, 64);

  // Jugador
  ctx.drawImage(mangonio, player.x - cameraX, player.y, player.width, player.height);

  // Enemigos
  enemies.forEach(e => {
    ctx.drawImage(enemyImg, e.x - cameraX - 12, e.y - 24, 48, 48);
  });

  // No dibujamos powerUps ni bloques (los quitamos)

  // Tubos
  pipes.forEach(p => {
    ctx.drawImage(pipeImg, p.x - cameraX, p.y, p.width, p.height);
  });

  // Minions (detrás del tubo y solo se ve la cara)
  minions.forEach(m => {
    // Solo mostrar la cara del minion
    // Asumo que la imagen del minion es cuadrada y su cara es la parte superior.
    // Dibujamos una sección recortada del minion (por ejemplo, 32x16 píxeles de la parte superior)
    const faceHeight = 16;
    ctx.save();
    // Dibujamos el minion detrás del tubo (antes de dibujar el tubo, ya dibujamos arriba, así que aquí pintamos en la posición adecuada)
    // Pero para que quede detrás del tubo, lo dibujamos *antes* que el tubo.
    // Aquí para hacerlo sencillo, lo dibujamos manualmente antes del tubo:
  });

  // Como el minion debe estar detrás del tubo, lo movemos arriba, y después dibujamos el tubo
  // Por eso: eliminamos la llamada anterior y la hacemos aquí, antes de dibujar el tubo.

  // Para mantener ordenado el código, repetimos dibujo minion acá:

  // Primero minion (cara solo) detrás del tubo:
  minions.forEach(m => {
    const faceHeight = 16;
    ctx.drawImage(
      minionImg,
      0, 0, m.width, faceHeight,        // recortamos la parte superior de la imagen (cara)
      m.x - cameraX, m.y + m.height - faceHeight, m.width, faceHeight  // posición (asomándose desde abajo hacia arriba)
    );
  });

  // Luego dibujamos el tubo (lo mismo que arriba)
  pipes.forEach(p => {
    ctx.drawImage(pipeImg, p.x - cameraX, p.y, p.width, p.height);
  });

  // Vidas y nivel
  ctx.fillStyle = "#fff";
  ctx.font = "16px monospace";
  ctx.fillText("Nivel " + level, 20, 30);
  for (let i = 0; i < lives; i++) {
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(width - 20 - i * 30, 30, 10, 0, Math.PI * 2);
    ctx.fill();
  }
}

function loop() {
  update();
  draw();
  setTimeout(() => requestAnimationFrame(loop), 1000 / 60);
}

resetLevel();
loop();
</script>
</body>
</html>
